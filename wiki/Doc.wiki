#summary howto add new iptv service support
<font color="red" size="3">_*- under develop !*_</font>
<wiki:toc max_depth="3" />

= Структура АПИ =

В каталоге /api хранятся `*`.py файлы с помощью которых можно добавлять свои сервисы. При запуске IPtvDream импортирует все файлы из /api и загружает найденные сервисы. Для каждого сервиса нужен свой файл в /api. Но не обязательно каждый файл в /api описывает какой-то сервис, это могут быть просто некоторые необходимые модули.

Чтоб объявить новый  сервис нужно в новом файле с /api объявить сlass *Ktv*.
При запуске дримбокса iptvdream просматривает каталог /api и импортирует список сервисов.
Каждый класс *Ktv* лучше определять как потомок класса *AbstractAPI*. И надо переопределить следующие поля:

||Имя переменной || тип || описание ||
|| *MODE* || MODE_STREAM или MODE_VIDEOS || определяет какие методы будет вызывать iptvdream. Далее будет описан каждый вариант плагина <font color="red">(на данный момент MODE_VIDEOS в разработке)</font> ||
|| *iName* || строка A-z || уникальное имя сервиса. Отображается в меню и является префиксом в настройках ||
|| *iProvider* || строка A-z || имя "провайдера". Под этим именем в настройках хранится логин и пароль. Может быть общей для разных сервисов. ||
|| *iTitle* || Любая строка || По умолчанию равна iName. Название сервиса в меню. В iName ставьте краткое имя! А тут можно любое, с любыми символами ||

На основание этих данных инициализируются настройки и строится меню сервисов. При запуске какого-то сервиса iptvdream создаёт объект типа Ktv.

 * *class Ktv(self, username, password):* сервису передаются логин и пароль из настроек

 * *start(self):* Далее происходит вызов этой функции. В этой функции должна произойти авторизация и другие действия необходимые для дальнейшей работы.

Так же можно реализовать следующие методы. Две функции для работы с настройками которые хранятся на удалённом сервере:
 
 * *getSettings(self)* Должен возвращать список настроек, элементы типа *settEntry*.

 * *pushSettings(self, sett):* Отправляет список настроек на сервер.
 
 * *trace(self, msg):* Используется для дебага, добавляет имя модуля iName в качестве префикса и печатает сообщение `<msg>`

Дальнейшие вызовы зависят от типа сервиса и будут рассмотрены дальше.

= Логика работы  плагина типа stream с API =

 * *setTimeShift(self, timeShift):* вызывается после start(). У некоторых сервисов есть возможность показывать каналы записанные несколько часов назад. Параметр timeShift передаётся в часах.

 * *setChannelsList(self):* вызывается следующей, в этой функции предполагается загрузка списка каналов. Если есть возможность получить этим же одним запросом EPG или другую информацию сделайте это тут, чтобы в дальнейшем IPtvDream не делал другие запросы, и время запуска ускорилось. Эта функция вызывается после setTimeShift, т.к. список каналов может зависеть от настроек сдвига времени. Далее будет описано поле channels, и класс class *Channel*.
 
 * *getPiconName(self, cid)* Используется для получения имени пикона, который будет отображён в инфобаре. По умолчанию возвращает `"%s:%s" % (self.iName, cid)` Но вы можете сделать поиск пикона например по имени канала, а не по cid. 

 * *getStreamUrl(self, cid, pin, time = None)* Должна возвращать ссылку на поток или *self.ACCESS_DENIED*. Если указан параметр `<time>`, то возвращать ссылку на архив или вызвать APIException если такой функции не предусмотрено. Параметр `<pin>` может быть паролем для доступу к защищённому каналу или None.

== Работа со списком каналов ==
Список каналов хранится в *Ktv.channels* типа dict. При вызове функции setChannelsList() сервис должен заполнить этот dict. Далее iptvdream сам разобьёт список каналов по группам, и отобразит его в меню выборов канала. Индексом (id) списка каналов является integer>0. Во всех дальнейших функциях (например запрос ЕПГ) iptvdream обращается по этому id. 
Элементы списка являются объектами класса *Channel*
 * *class Channel(self, name, group, num, groupnum, archive=0):*
  * name - имя канала, отображается в списке
  * group - имя группы, используется для сортировки каналов по группам
  * num - "номер" канала, альтернативный ключ для сортировки каналов, некоторые пользователи хотят видеть каналы расположенные не по алфавиту, а так как они идут в плейлисте, или в веб интерфейсе на сервре iptv провайдера..
  * groupnum - аналогично для групп
  * archive - доступна ли функция архива.

У класса iptvdream есть функция закрытия некоторых каналов родительским паролем enigma2, для этого у Ktv есть следующее поле:
||Имя переменной || тип || описание ||
|| *locked_cids* || list || Список id каналов, которые будут закрыты паролем если включена функция родительский контроль в enigma2. добавляются в blacklist при старте iptvdream или при вызове setChannelsList. ||
|| *HAS_PIN* || определяет есть ли функция закрытия кодом канала на сервере, т.е. необходимо ли при вызове getStreamUrl передавать `<pin>` для каналов из списка locked_cids ||

Таким образом если каналы закрываются средствами самого сервиса то для списка locked_cids будет использоваться этот метод, если же такой функции нету то каналы закрываются средствами плагина. Более того в любом случае через меню пользователь средствами плагина может закрыть любой канал.

== Paбота с EPG ==
При работе с EPG все переменные времени являются объектами типа datetime.datetime

Чтобы сделать более универсальную поддержку сервисов с различными алгоритмами получения EPG iptvdream использует свои промежуточные функции. В своем классе Ktv вы должны реализовать загрузку и парсинг EPG и добавлять его в сlass Channel, когда IPtvDream это попросит. Каждая программа должна являться классом *EpgEntry*.
 * *class EpgEntry(self, name, t_start, t_end)*
  * name - полное описание передачи
  * t_start - время начала передачи
  * t_end - время окончания, не обязательно можно None, но в таком случае может быть невозможным показ длительности передачи.

Если необходимо показать список каналов, IPtvDream хочет показать EPG для этих каналов. Вызывается функция
 * *def getChannelsEpg(self, cids)* Параметр cids - список id необходимых каналов. Если есть возможность получить не только текущие передачи на каналах, но и следующую передачу сделайте это.

В режиме просмотра какого-то одного канала, IPtvDream хочет получить текущую и следующую передачу на этом канале. Вызываются функции
 * *getCurrentEpg(self, cid)* Параметр cid - id нужного канала. Если нет возможность получить текущую и следующую передачу одним запросом (или вообще невозможно получить следующую передачу), вы должны реализовать получение следующей передачи в getNextEpg(self, cid). Для большей скорости работы лучше получить всю информацию одним запросом.

 * *getNextEpg(self, cid)* Здесь предполагается получение информации о следующей передачи на канале с id равным параметру cid.

Для аналогичной ситуации но при работе с архивом используются функции
 * *getGmtEpg(self, cid, time)* Получение передачи, которая шла на канале в момент времени time типа datetime.

 * *getNextGmtEpg(self, cid, time)* Аналогично для следующей передачи.

Если нужно показать телепрограмму на день
 * *getDayEpg(self, cid, date)* Запрос EPG на сутки, дата которых совпадает с соответствующими параметрами date.

В приведенных выше функциях необходимо сделать парсинг EPG, и добавление его к какому-то каналу с помощью следующих методов класса *Channel*
 * *pushEpg(self, epg_entry)* Добавить одну программу
 
 * *pushEpgSorted(self, epg_list)* Добавить список программ, идущих _подряд!_ В этой функции t_end следующей программы автоматически присваивается t_start предыдущей.

== Алгоритм EPG ==
<font color="red">[БД пока нету, используется питоновский dict]</font>
<div class="mylist">
 * Запуск сервиса, авторизация и т д.
 * Загрузка базы EPG сохранённой с прошлого запуска <font color="red">_under develop_</font>
 * Одиночное ЕПГ канала для времени time
  * Поиск в БД записи (start_t, end_t) для которго start_t <= time < end_t,  записи без end_t игнорируются
  * Если не найдено, то вызов getCurrentEpg()/getGmtEpg(time)
  * Повторение поиска по БД.
 * Текущее ЕПГ списка каналов во время time_now
  * Поиск в БД записей (start_t, end_t) для которых start_t <= time_now < end_t, записи без end_t игнорируются
  * Если не найдены, то вызов getChannelsEpg([список id для которых не найдено])
  * Повторный поиск.
 * Текущее + следующее ЕПГ для канала, прямо сейчас / в момент времени time
  * Поиск одиночного ЕПГ канала для времени time
  * Продолжаем, если найдено (curr_start, curr_end)
  * Поиск в БД записей для которых start_t == curr_end
  * Если не найдено, то вызов getNextEpg()/getNextGmtEpg(time)
  * Выбор элемента идущего сразу после (curr_start, curr_end)
 * ЕПГ для канала на день, с датой date_now = datetime(year_now, month_now, day_now)
  * d_start и d_end присваиваются значения окончания и начала суток + расширение интервала на 6 часов. 
  * Поиск в БД первого элемента для которого start_t > d_start
  * Выбор списка следующих непрерывно идущих элементов, т.е. end_t[i] == start_t[i+1] но до момента времени d_end
  * Проверка длины получившегося списка (start_t[first] - (end_t[last] or start_t[last])) > EPG_DAY_LENGTH
  * Если false, то вызов getDayEpg(id, day_now)
  * Повтор поиска, но _без проверки на длину_
</div>

==== Список EPG функций которые нужны нашему GUI ====
 * получить передачу в заданный момент времени. А так же её время начала, окончания, полную длину и время оставшееся до окончания.
 * получить передачу которая будет после передачи идущей в заданный момент времени. А так же её время начала, окончания и полную длину.
 * Предыдущие две функции для списка каналов.
 * Получить список передач в заданном интервале времени, включая передачи частично попавшие в заданный интервал времени. А так же их время начала и окончания.
 * Предыдущая функция для списка каналов.
 * В перспективе поиск по передачам.

Функция
Описание
epgCurrent(self, time)
Returns EpgEntry that goes at given time
epgNext(self, time)
Returns EpgEntry that goes just after epgCurrent
epgPeriod(self, tstart, tend)
Returns list of EpgEntry
epgDay(self, date)
Returns epgPeriod from tstart = date to date + 24 hours

Функции которые должно предоставлять API

EpgEntry class

class EpgEntry():

EpgEntry(self, name, t_start, t_end):
 * name — all available text info about the program. (First line is treated as program headline, next lines are description)
 * t_start — time of the begining  of the program.
 * t_end — time of the ending of the program. Some epg services doesn't provide such information, so this parameter is not neseccary(could be set to None)

Запросы на обновление информации в кэше.
- Аналогичны запросам получения EPG
- Плюс какая то функция для оптимальной загрузки всего EPG. (В перспективе будет использоваться в бэкграунде)

= Exceptions =
Если во время вызова какого-то метода сервиса возникает ошибка, то это приведёт к падению enigma2, кроме случая когда тип исключения сlass *APIException* (Определён в utils.py). Tаким образом все возможные исключения в сервисе должны быть заключены в try-except. Например случай с подключением к удалённому серверу:
{{{
try:
   reply = self.opener.open(self.site+'/api/xml/login?', params).read()
except:
   raise APIException("connection to server failed!")
}}}
Такое исключение iptvdream обработает и покажет указанное сообщение об ошибке.